# Internationalization (i18n)

The app supports English (`en`) and Ukrainian (`ua`) via a React Context-based system.

## Key files

| File | Purpose |
| --- | --- |
| `src/context/LanguageContext.jsx` | Context provider: state, toggle, translation function |
| `src/i18n/en.json` | English strings |
| `src/i18n/ua.json` | Ukrainian strings |

## How it works

### Language state

On mount, the provider reads the saved locale from `localStorage` (key: `lang`). If nothing is saved, it defaults to `'en'`. The chosen language persists across page reloads.

### Switching languages

`toggleLanguage` flips between `'en'` and `'ua'` and writes the new value to `localStorage`.

### How translations are loaded

Both JSON files are imported as plain JS objects and merged into one object by key:

```js
const translations = { en, ua };
// → { en: { hero: { headline: "..." }, ... },
//     ua: { hero: { headline: "..." }, ... } }
```

`{ en, ua }` is shorthand for `{ en: en, ua: ua }` — each language stays separate under its own key. `translations[language]` picks the right one at runtime.

### Translating strings — `t(key)`

The `t` function accepts a dot-notation key and walks the nested translation object step by step:

```js
t('hero.headline')
```

1. `'hero.headline'.split('.')` → `['hero', 'headline']`
2. `value` starts as the full object for the current language: `{ hero: { headline: "..." }, ... }`
3. The loop walks one level deeper per segment:
   - after `'hero'`: `value = { headline: "Trusted Ukrainian..." }`
   - after `'headline'`: `value = "Trusted Ukrainian..."`
4. Returns the final value — or the raw key string if anything along the path was `undefined`

If a key is missing, `?.` prevents a crash and `|| key` returns the key itself (e.g. `"hero.headline"`), making gaps easy to spot in the UI.

## Usage in a component

```jsx
import { useContext } from 'react';
import { LanguageContext } from '../context/LanguageContext';

function MyComponent() {
  const { t, language, toggleLanguage } = useContext(LanguageContext);

  return (
    <>
      <h1>{t('hero.headline')}</h1>
      <button onClick={toggleLanguage}>
        {language === 'en' ? 'UA' : 'EN'}
      </button>
    </>
  );
}
```

## Adding a new string

1. Add the key/value to `src/i18n/en.json`
2. Add the translation to `src/i18n/ua.json`
3. Use `t('your.key')` in the component

Nested keys are supported to any depth — use dot notation to access them.

## Adding a new language

1. Create `src/i18n/<code>.json` with all translated strings
2. Import it in `LanguageContext.jsx` and add it to the `translations` map
3. Update `toggleLanguage` to cycle through the new locale
